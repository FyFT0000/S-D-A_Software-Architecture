https://www.coursera.org/learn/software-architecture?specialization=software-design-architecture

Software Architecture
    Ways architectures are represented, both in UML and other visual tools. Most common architectures, their qualities, and tradeoffs.


3.1.1 – Architecture Overview and Process
Software architecture is the fundamental design of an entire software system. It defines what elements are included in the system, what function each element has, and how each element relates to one another. It is the big picture or overall structure of the whole system—how everything works together.
_   It follows that to design a software system, a software architect has to take many factors into consideration:
    _the purpose of the system,
    _the audience or users of the system,
    _the qualities that are of most importance to users, and
    _where the system will run.
_   Software architecture is important, particularly for large systems. If there is a clear design of the overall system from the start, there is a solid basis for developers to follow. Each developer will then know what needs to be implemented and how things are related to meet desired needs efficiently. This avoids conflicts, duplication, and ad hoc unnecessary work.
_   Some advantages of software architecture include:
    _higher productivity for the software team, as a well-defined structure helps to coordinate work, implement individual features, or guide discussions on potential issues.
    _improved evolution for the software, since design principles are applied to make changes easier to accomplish or defects easier to find.
    _enhanced quality in the software by carefully considering the needs and perspectives of all the stakeholders.
_   Software architecture typically have the following stakeholders:
    _Software developers: Software architecture helps developers create and evolve software by providing strong direction and organization on what needs to be done.
    _Project Managers: Software architecture provides useful information to project managers to help them identify possible risks and to manage the project successfully. Software architecture helps project managers to understand task dependencies and impacts of change and to coordinate work assignments.
    _Clients: Clients make important decisions about the system, like its funding. Software architecture establishes a basis for communication with clients, so they understand what they are paying for and that their needs are met.
    _End users: Users may not care how the software is actually designed, but they do care that it “works well” for them.

3.1.2 – Kruchten's 4 + 1 Model View
This model is a way of understanding the key considerations or important perspectives that need to be addressed in software architecture.
_   Logical View: focuses on the functional requirements of a system, usually involves the objects of the system. From these objects, a UML class diagram can be created to illustrate the logical view.
    _A class diagram establishes the vocabulary of the problem and resulting system. By defining all of the classes, their attributes, and their behaviours it becomes easy to understand the key abstractions and terminology. Class diagrams are also useful for specifying database schemes. The class diagram makes it easier to see how classes interact and how data should relate to each other in a database.
    _Some of the most effective UML diagrams related to the logical view of a system are the class diagram and the state diagram. Both the class diagram and the state diagram focus on the classes and objects of a system.
_   Process View: focuses on achieving non-functional requirements. These are the requirements that specify the desired qualities for the system, which include quality attributes such as performance and availability. The process view also presents processes that correspond to the objects in the logical view.
    _Some of the most effective UML diagrams related to the process view of a system are the activity diagram and the sequence diagram. The activity diagram can illustrate the processes or activities for a system. The sequence diagram shows how objects interact with one another, which involves how methods are executed and in what order.
_   Development View: describes the hierarchical software structure. It also considers elements such as programming language, libraries, and toolsets. It is concerned with the details of software development and what is involved to support that. This extends to management details such as scheduling, budgets, and work assignments. Essentially, the development view covers the hierarchical software structure and project management.
_   Physical View: handles how elements in the logical, process, and development views must be mapped to different nodes or hardware for running the system.
    _One of the most effective UML diagrams related to the physical view of a system is the deployment diagram. It can express how the pieces of a system are deployed onto hardware or execution environments.
_   Scenarios: align with the use cases or user tasks of a system and show how the four other views work together. For each scenario, there is a script that describes the sequence of interactions between objects and processes. This involves the key objects defined in the logical view, the processes described in the process view, the hierarchy identified in the development view, and the different nodes specified in the physical view. Scenarios relate these elements to provide a complete picture.
_   None of the views are fully independent of each other, with elements of some views connected to others. The 4+1 view model can be molded to fit many situations to understand the architecture of a software system. Being able to see a complex problem in many different perspectives helps make your software more versatile.

3.1.3 – UML Component Diagram
Are concerned with the components of a system.
_   Components are the independent, encapsulated units within a system. Each component provides an interface for other components to interact with it. Component diagrams are used to visualize how a system’s pieces interact and what relationships they have among them.
_   Component diagrams are different from most other diagrams, as they show high-level structure and not details like attributes and methods. They are purely focused on components and their interactions with each other. Component diagrams are a static view of the software system, and depict the system design at a specific point in its development and evolution. The basis of component diagrams focuses on the components and their relationships. Each component in a diagram has a very specific relationship to the other components through the interface it provides.
_   Component diagrams have:
    _Ball connectors: which represent a provided interface. A provided interface shows that a component offers an interface for others to interact with it. The provided interface means that client and consumer components have a way of communicating with that component.
    _Socket connectors: that display a required interface. The required interface is essential to the component diagram, to show that a component expects a certain interface. This required interface is to be satisfied or provided by some other component.
    _Assembly relationship: occurs when one component’s provided interface matches another component’s required interface. The provided interface is depicted by a ball, and the required interface is depicted by a socket.
_   To build a component diagram:
    _First, you must identify the main objects used in the system.
    _Next, the relevant libraries for the system need to be identified.
    _Finally, the relationship between these components would need to be identified. When relevant libraries are identified, this extends to third-party implementation dependencies, which should also be integrated into the diagram where relevant.
_   Component diagrams are especially useful early in the design process, because of its high-level emphasis. They can be drawn at different levels and allows you to focus not only on systems but on subsystems as well.

3.1.4 – UML Package Diagram
Show packages and the dependencies between them.
_   These diagrams can organize a completed system into packages of related packageable elements, which could include data, classes, or even other packages. Package diagrams help provide high-level groupings of a system so that it is easy to see how a package contains related elements as well as how different packages depend on each other.
_   A package groups together elements of software that are related. Elements can be related based on data, classes, or user tasks. A package can also define a “namespace” for elements it contains, that is, a package is named and can organize the named elements of software into a separate scope. An element can be uniquely identified in the system by a fully “qualified name” that is based on its own name and the name of the package that the element is in.
_   Packages are depicted by tabbed folders. If there are no elements to show in the package, then the package name goes into the centre of the folder. If details are needed, there are two ways this can be expressed: The elements can be nested within the folder. Alternately, oyher notation can be used. Contained elements can also be listed in a package by their names. These names can be partially qualified, but they should be unique within the package.
_   Relationships are denoted through dotted-line
arrows:
    _A package can <<import>> an element from another package or can import the entire contents of other packages. Import tag is public.
    _A package can do a private import, as indicated by the <<access>> tag
    _A package can <<uses>> relationship also. Implies that the package requires other for its full implementation.
    _Packages can also be <<merge>>. Merging typically occurs when two packages or concepts need to come together into one. This is a use of generalization that allows different definitions to be provided for the same concept.
_   Package diagrams can be created at any stage of development. They can also adapt and change with the latest version of software being worked on. Package diagrams are particularly useful for technical designers because they allow them to see the dependencies and relations between groups of related elements.

3.1.5 – UML Deployment Diagram
Are used to visualize the deployment details of a software system. The diagrams include more than just code, but also separate libraries, an installer, configuration files, and many other pieces. In order for software to be ready to run, it is necessary to understand all the files and executables involved and the environments where they reside.
_   The deployment environment, or deployment target, can be very specific and involve particular hardware devices. It can also be very general and involve supported operating systems. Details in a deployment diagram change accordingly. For example, software developed for Linux, MacOS or Windows may have differences from one another.
_   Deployment diagrams deal with artifacts. Artifacts are a physical result of the development process. Artifacts for a video game might include things like an executable to run the game, an installer to install the game, audio libraries for sound, and multimedia assets. These are created as outcomes of producing the system and are the final pieces to be put together.
_   There are two different types of deployment diagrams:
    _Specification-level diagrams: provides an overview of artifacts and deployment targets, without referencing specific details like machine names. It focuses on a general overview of your deployment rather than the specifics.
    _Instance level diagrams: is a more specific approach that maps specific artifacts to specific deployment targets. They can identify specific machines and hardware devices. This approach is usually used to highlight the differences in deployments among development, staging, and release builds.
_   When creating deployment diagrams, it is important to use the correct notation for the various elements:
    _Nodes: are deployment targets that contain artifacts available for execution.In a deployment diagram, they look like 3D boxes. Hardware devices are also displayed as 3D boxes, only they have a “device” tag on them to differentiate them.
    _Relationships can be represented as a solid line between two nodes, that shows a relationship between deployment targets. The line shows that the two nodes have a communication path between them. This relationship typically identifies a particular communication protocol.
        _Manifestation is a relationship where an artifact is a physical realization of a software component. It can be represented with a “manifests” indicatr.
_   If an artifact is drawn inside a node box, this shows that an artifact is deployed to a node. This also means that the artifact cannot function without this deployment target.
_   In a deployment diagram, there is a distinct hierarchy of deployment targets. This hierarchy is very important. You should start from the highest level of your deployment information, from application name down to device and operating system.
_   Deployment diagrams help provide consistency and organization to deployments, which helps avoid system failures. The diagrams also help keep track of the files and executables needed to deploy and run the software. The diagram can be on an instance level specific to the deployment machines you are using, or it can be general for a range of execution environments.

3.1.6 – UML Activity Diagram
Allows the representation of the control flow from activity to another in a software system. It captures the dynamic behaviour of the system and allows the mapping of branching into alternative flows.
_   Activities: are actions that further the flow of execution in a system. They are actions that when completed cause another action to execute. For example, an action can alter or create new objects. These changes or actions can drive your application forward. In order to create an activity diagram, you must:
    _1. Identify the activities.
    _2. Identify the respective conditions of the system’s activities.
_   There are a few major parts to an activity diagram:
    _Start and End: notes that look like labelled circles. These circles are where the diagram must begin. They show the starting activity that initializes the control flow of the application. The end node shows the final activity of the diagram.
    Intermediate activities are shaped like an oval, and they describe all of the activities that change the game state before the game ends.
    _Decision nodes: are diamonds that have an activity leading into it, and there is the possibility of two alternative outcomes as the next activity. The choice of outcome depends on how the condition on the decision node evaluates.
    _Partitions: divide activities up into different categories.
such as where it occurs, or the user role involved. 
_   All essential activities must be included in a diagram as well as the conditions.
_   Activity diagrams allow the mapping of concurrent activities that happen in parallel. A fork in the flow moves into parallel flows, so activities can happen at the same time. Parallel flows can join into a single flow. To denote this, activity diagrams can use a separate swimlane for each flow denotating Partitions. Swimlanes can also divide activities up into different categories, such as where it occurs or the user role involved. Arrows crossing each lane show how different activities of a system interact across categories.
_   Activity diagrams allow you to see what activities and conditions should be included in a system. As well, from the diagrams you see the order in which features are encountered while also allowing for alternate flows to be taken into account for the system.
















































